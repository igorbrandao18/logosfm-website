name: Build and Deploy Docker Image

on:
  push:
    branches:
      - main
      - master
  pull_request:
    branches:
      - main
      - master

jobs:
  build:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      
      - name: Build Docker image
        run: |
          docker build -t logosfm-website:latest .
      
      - name: Test Docker image
        run: |
          docker run -d -p 7777:8000 --name test-container logosfm-website:latest
          sleep 5
          curl -f http://localhost:7777 || exit 1
          docker stop test-container
          docker rm test-container

  deploy:
    needs: build
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master')
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Install dependencies
        run: |
          sudo apt-get update && sudo apt-get install -y sshpass
      
      - name: Copy files to server
        env:
          SERVER_IP: ${{ secrets.SERVER_IP }}
          SERVER_USER: ${{ secrets.SERVER_USER }}
          SERVER_PASSWORD: ${{ secrets.SERVER_PASSWORD }}
        run: |
          set -e
          
          # Criar diretório no servidor se não existir (com timeout)
          echo "Creating directory on server..."
          timeout 30 sshpass -p "$SERVER_PASSWORD" ssh -o StrictHostKeyChecking=no -o ConnectTimeout=10 $SERVER_USER@$SERVER_IP "mkdir -p /opt/logosfm-website" || exit 1
          
          # Criar arquivo tar em diretório temporário para evitar conflito
          echo "Creating tarball..."
          mkdir -p /tmp/deploy
          tar --exclude='.git' --exclude='__MACOSX' --exclude='node_modules' \
              --exclude='.github' -czf /tmp/deploy/site-files.tar.gz .
          
          # Copiar arquivo tar para o servidor (com timeout)
          echo "Copying files to server..."
          timeout 120 sshpass -p "$SERVER_PASSWORD" scp -o StrictHostKeyChecking=no -o ConnectTimeout=10 \
            /tmp/deploy/site-files.tar.gz \
            $SERVER_USER@$SERVER_IP:/opt/logosfm-website/ || exit 1
          
          # Extrair arquivos no servidor (com timeout)
          echo "Extracting files on server..."
          timeout 60 sshpass -p "$SERVER_PASSWORD" ssh -o StrictHostKeyChecking=no -o ConnectTimeout=10 $SERVER_USER@$SERVER_IP bash << 'EOF' || exit 1
            cd /opt/logosfm-website
            tar -xzf site-files.tar.gz
            rm site-files.tar.gz
EOF
          
          # Limpar arquivo tar local
          rm -rf /tmp/deploy
          echo "Files copied successfully!"
      
      - name: Deploy site on server
        env:
          SERVER_IP: ${{ secrets.SERVER_IP }}
          SERVER_USER: ${{ secrets.SERVER_USER }}
          SERVER_PASSWORD: ${{ secrets.SERVER_PASSWORD }}
        run: |
          set -e
          # Fazer build e restart do container do site no servidor
          timeout 300 sshpass -p "$SERVER_PASSWORD" ssh -o StrictHostKeyChecking=no -o ConnectTimeout=10 $SERVER_USER@$SERVER_IP << 'EOF'
            cd /opt/logosfm-website
            
            # Verificar se docker-compose está instalado, se não, instalar
            if ! command -v docker-compose &> /dev/null; then
              echo "Installing docker-compose..."
              curl -L "https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
              chmod +x /usr/local/bin/docker-compose
            fi
            
            # Parar containers existentes do site
            docker-compose down || true
            
            # Build e start do site
            docker-compose build --no-cache
            docker-compose up -d
            
            # Verificar status do site
            docker-compose ps
            echo "Site deploy completed successfully!"
          EOF
      
      - name: Deploy AzureCast on server
        env:
          SERVER_IP: ${{ secrets.SERVER_IP }}
          SERVER_USER: ${{ secrets.SERVER_USER }}
          SERVER_PASSWORD: ${{ secrets.SERVER_PASSWORD }}
        run: |
          set -e
          # Instalar/atualizar AzureCast usando método oficial
          timeout 600 sshpass -p "$SERVER_PASSWORD" ssh -o StrictHostKeyChecking=no -o ConnectTimeout=10 $SERVER_USER@$SERVER_IP << 'EOF'
            cd /opt/logosfm-website/azurecast
            
            # Baixar script oficial se não existir
            if [ ! -f "docker.sh" ]; then
              curl -fsSL https://raw.githubusercontent.com/AzuraCast/AzuraCast/main/docker.sh > docker.sh
              chmod a+x docker.sh
            fi
            
            # Se já estiver instalado, apenas atualizar
            if [ -f ".env" ] && [ -f "docker-compose.yml" ]; then
              echo "AzureCast already installed, updating..."
              docker-compose down || true
              ./docker.sh update || yes '' | ./docker.sh install
            else
              echo "Installing AzureCast for the first time..."
              yes '' | ./docker.sh install
            fi
            
            # Configurar porta 8000 mapeando para porta 80 interna do container (porta 80 host está em uso pelo Nginx)
            echo "Configuring AzureCast to use port 8000 (host) -> 80 (container)..."
            if [ -f "docker-compose.yml" ]; then
              # Substituir mapeamento de porta para 8000:80 (host:container) - apenas a primeira ocorrência
              sed -i "0,/'\\\${AZURACAST_HTTP_PORT:-80}:\\\${AZURACAST_HTTP_PORT:-80}'/s/'\\\${AZURACAST_HTTP_PORT:-80}:\\\${AZURACAST_HTTP_PORT:-80}'/'8000:80'/" docker-compose.yml
              # Remover linhas de portas hardcoded que podem causar conflito (8000:8000, 8005:8005, etc)
              sed -i "/^[[:space:]]*- '8000:8000'/d" docker-compose.yml
              sed -i "/^[[:space:]]*- '8005:8005'/d" docker-compose.yml
              sed -i "/^[[:space:]]*- '8006:8006'/d" docker-compose.yml
            fi
            # Remover override antigo se existir
            rm -f docker-compose.override.yml
            
            # Reiniciar com nova configuração
            docker-compose down || true
            docker-compose up -d
            
            # Aguardar inicialização
            sleep 15
            
            # Verificar status
            ./docker.sh ps || docker-compose ps
            echo "AzureCast deploy completed successfully!"
          EOF
      
      - name: Verify deployment
        env:
          SERVER_IP: ${{ secrets.SERVER_IP }}
          SERVER_USER: ${{ secrets.SERVER_USER }}
          SERVER_PASSWORD: ${{ secrets.SERVER_PASSWORD }}
        run: |
          sleep 5
          
          # Verificar site (porta 7777)
          echo "Verifying site on port 7777..."
          sshpass -p "$SERVER_PASSWORD" ssh -o StrictHostKeyChecking=no $SERVER_USER@$SERVER_IP "curl -f http://localhost:7777 || exit 1"
          echo "Site verified successfully!"
          
          # Verificar AzureCast (porta 8000) - opcional, pode não estar rodando ainda
          echo "Verifying AzureCast on port 8000..."
          sshpass -p "$SERVER_PASSWORD" ssh -o StrictHostKeyChecking=no $SERVER_USER@$SERVER_IP "curl -f http://localhost:8000 || echo 'AzureCast not running yet (this is OK if not installed)'"
          
          echo "Deployment verification completed!"

